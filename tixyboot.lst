     1                                  ; tixyboot.asm by Rick Companje, 2021-2022, MIT licence
     2                                  ; a tribute to Martin Kleppe's beautiful https://tixy.land
     3                                  ; as well as a tribute to the Sanyo MBC-550/555 PC (1984)
     4                                  ; which forced me to be creative with code since 1994.
     5                                  ;
     6                                  ; The Sanyo MBC-55x has a very limited ROM BIOS. After some 
     7                                  ; hardware setup by the ROM BIOS a RAM BIOS loaded from
     8                                  ; floppy takes over. This means that we don't have any BIOS
     9                                  ; functions when running our own code from the bootsector. 
    10                                  ;
    11                                  ; The Sanyo has no display mode 13 (not even with the original
    12                                  ; RAM BIOS). It uses a 6845 video chip with three bitmapped 
    13                                  ; graphics planes and is organized as 50 rows by 72 (or 80) columns.
    14                                  ; One column consists of 4 bytes. Then the next column starts.
    15                                  ; After 72 columns a new row starts. A bitmap of 16x8 pixels 
    16                                  ; is made up of 2 columns on row 1 and 2 columns on row 2...
    17                                  ;
    18                                  ; To run this code write the compiled code to the bootsector of a
    19                                  ; Sanyo MBC-55x floppy or use an emulator like the one written
    20                                  ; in Processing/Java in this repo.
    21                                  ;
    22                                  ; Add your own visuals by adding your own functions to the fx_table.
    23                                  ;
    24                                  ; t = time  0..255
    25                                  ; i = index 0..255
    26                                  ; x = x-pos 0..15
    27                                  ; y = y-pos 0..15
    28                                  ;
    29                                  ; result: al -15..15 (size and color)
    30                                  ;         al<0 red, al>0 white
    31                                  
    32                                  org 0
    33                                  cpu 8086
    34                                  
    35                                  COLS  equ 72
    36                                  TOP   equ 9*4*COLS+20*4    ; row=9,col=20
    37                                  RED   equ 0xf0
    38                                  GREEN equ 0x08
    39                                  BLUE  equ 0xf4
    40                                  
    41                                  effect_timeout equ 30      ; every 30 frames another effect
    42                                  isqrt_table    equ 1000    ; available location in code segment
    43                                  
    44                                  ; using dx and bx registers as t,i,x,y variables
    45                                  %define t dh
    46                                  %define i dl
    47                                  %define x bh
    48                                  %define y bl
    49                                  
    50 00000000 E9B700                  jmp setup
    51                                  
    52                                  sin_table: ;31 bytes, (input -15..15 index=0..31)
    53 00000003 00FDFAF7F5F3F1F1F1-         db 0,-3,-6,-9,-11,-13,-15,-15,-15,-15,-13,-11,-9,-6,-3,
    53 0000000C F1F3F5F7FAFD       
    54 00000012 000306090B0D0F0F0F-         db 0, 3, 6, 9, 11, 13, 15, 15, 15, 15, 13, 11, 9, 6, 3,0  
    54 0000001B 0F0D0B09060300     
    55                                      ; tried to mirror the second line of the sine table with code 
    56                                      ; but would take a same of amount of bytes
    57                                  
    58                                  fx_table:      ; the 'effects' table: 8 bytes, overwriting the 'Sanyo1.2' tag
    59 00000022 [2D][28][36][40]-           db fx0,fx1,fx2,fx3,fx4,fx5
    59 00000026 [4B][59]           
    60                                  
    61                                  fx1: ; y+t
    62 00000028 88D8                        mov al,y
    63 0000002A 00F0                        add al,t
    64 0000002C C3                          ret
    65                                  
    66                                  fx0: ; ?
    67                                      ; push bx
    68                                      ; push ds
    69                                      ; mov ax,0xff00
    70                                      ; mov ds,ax
    71                                      ; xor ax,ax
    72                                      ; ; mov al,i
    73                                      ; add al,t
    74                                      ; mov bx,ax
    75                                      ; xlat
    76 0000002D 88F8                        mov al,x
    77 0000002F 30D8                        xor al,y
    78 00000031 08F0                        or al,t
    79 00000033 2C07                        sub al,7
    80                                  
    81                                      ; pop ds
    82                                      ; pop bx
    83 00000035 C3                          ret
    84                                  
    85                                  fx2: ; sin(x+y+t)
    86 00000036 88F8                        mov al,x
    87 00000038 00D8                        add al,y
    88 0000003A 00F0                        add al,t
    89 0000003C E82800                      call sin
    90 0000003F C3                          ret
    91                                  
    92                                  fx3: ; bitmap_data[i+t]
    93 00000040 53                          push bx
    94 00000041 88D0                        mov al,i
    95 00000043 00F0                        add al,t
    96 00000045 BB[ED01]                    mov bx,bitmap_data
    97 00000048 D7                          xlat
    98 00000049 5B                          pop bx
    99 0000004A C3                          ret
   100                                  
   101                                  fx4: ; ((y-x)*-8)+t
   102 0000004B 88D8                        mov al,y
   103 0000004D 28F8                        sub al,x
   104 0000004F B1F8                        mov cl,-8
   105 00000051 F6E1                        mul cl
   106 00000053 E82E00                      call limit
   107 00000056 00F0                        add al,t
   108 00000058 C3                          ret
   109                                  
   110                                  fx5: ; sin(sqrt(x^2+y^2))-t)
   111 00000059 88D0                        mov al,i   ; isqrt_table[i] = sqrt(x^2+y^2)
   112 0000005B 53                          push bx
   113 0000005C BBE803                      mov bx,isqrt_table
   114 0000005F D7                          xlat
   115 00000060 5B                          pop bx
   116 00000061 28F0                        sub al,t
   117 00000063 E80100                      call sin
   118 00000066 C3                          ret
   119                                  
   120                                  sin: ; sine function
   121 00000067 E80900                      call wrap
   122 0000006A 53                          push bx
   123 0000006B 040F                        add al,15 ; sin(-15) = sin_table[0]
   124 0000006D BB[0300]                    mov bx,sin_table
   125 00000070 D7                          xlat 
   126 00000071 5B                          pop bx
   127 00000072 C3                          ret
   128                                  
   129                                  wrap: ; while (al>15) al-=15; while (al<-15) al+=15
   130 00000073 3C0F                        cmp al,15
   131 00000075 7F05                        jg .sub16
   132 00000077 3CF1                        cmp al,-15
   133 00000079 7C05                        jl .add16
   134 0000007B C3                          ret
   135                                    .sub16:
   136 0000007C 2C1F                        sub al,31
   137 0000007E EBF3                        jmp wrap
   138                                    .add16:
   139 00000080 041F                        add al,31
   140 00000082 EBEF                        jmp wrap
   141                                  
   142                                  limit: ; if (al>15) al=15; else if (al<-15) al=-15;
   143 00000084 3C0F                        cmp al,15
   144 00000086 7F07                        jg .pos16
   145 00000088 3CF1                        cmp al,-15
   146 0000008A 7D05                        jnl .ret
   147 0000008C B0F1                        mov al,-15
   148 0000008E C3                          ret
   149                                    .pos16:
   150 0000008F B00F                        mov al,15
   151                                    .ret:
   152 00000091 C3                          ret
   153                                  
   154                                  calc_isqrt_xx_yy: ; isqrt_table[i] = sqrt(x^2+y^2)
   155 00000092 52                          push dx
   156 00000093 57                          push di
   157 00000094 BFE803                      mov di,isqrt_table      ; di=isqrt_table[0]
   158 00000097 01D7                        add di,dx               ; di+=i
   159 00000099 88F8                        mov al,x
   160 0000009B FEC0                        inc al
   161 0000009D F6E0                        mul al                  ; x*x
   162 0000009F 91                          xchg ax,cx
   163 000000A0 88D8                        mov al,y
   164 000000A2 FEC0                        inc al
   165 000000A4 F6E0                        mul al                  ; y*y
   166 000000A6 01C8                        add ax,cx               ; + 
   167                                    .isqrt:  ; while((L+1)^2<=y) L++; return L
   168 000000A8 91                          xchg cx,ax              ; cx=y
   169 000000A9 31C0                        xor ax,ax               ; ax=L=0
   170                                    .loop:
   171 000000AB 40                          inc ax
   172 000000AC 50                          push ax
   173 000000AD F7E0                        mul ax
   174 000000AF 39C8                        cmp ax,cx
   175 000000B1 58                          pop ax
   176 000000B2 7CF7                        jl .loop
   177 000000B4 48                          dec ax
   178                                    .end_isqrt:
   179 000000B5 8805                        mov [di],al             ; store al
   180 000000B7 5F                          pop di
   181 000000B8 5A                          pop dx
   182 000000B9 C3                          ret
   183                                  
   184                                  setup:                      ; starting point of code
   185                                  
   186                                      ;no need to clear the screen. ROM BIOS does this already.
   187                                  
   188                                      ;set ds and es segments to cs
   189 000000BA 0E                          push cs
   190 000000BB 1F                          pop ds                  ; ds:si in code segment
   191 000000BC 0E                          push cs
   192 000000BD 07                          pop es                  ; es:di in code segment
   193                                  
   194                                      ; generate 16x8 bitmap data for 16 sizes of dots.
   195                                      ; Because the dots are symmetric we can save at least
   196                                      ; 97 bytes by mirroring the left-top corner 3 times
   197                                  
   198 000000BE E89000                      call generate_chars
   199                                  
   200 000000C1 31ED                        xor bp,bp               ; start with effect 0
   201 000000C3 31D2                        xor dx,dx               ; t=i=0 (clear time and index)
   202                                  
   203                                  draw:
   204 000000C5 BF700A                      mov di,TOP              ; left top corner to center tixy
   205                                  dot:
   206 000000C8 52                          push dx
   207 000000C9 88D0                        mov al,i                ; al=index
   208 000000CB 30E4                        xor ah,ah               ; ah=0
   209 000000CD B110                        mov cl,16
   210 000000CF F6F1                        div cl                  ; calculate x and y from i
   211 000000D1 93                          xchg ax,bx              ; bh=x, bl=y
   212 000000D2 5A                          pop dx
   213                                  
   214                                      ;on the first frame calc sqrt table for every i
   215                                      ;reusing the i,x,y loop here. this saves some bytes.
   216 000000D3 08F6                        or t,t
   217 000000D5 7503                        jnz .cont
   218 000000D7 E8B8FF                      call calc_isqrt_xx_yy
   219                                    .cont:
   220                                     
   221 000000DA 55                          push bp
   222 000000DB 53                          push bx
   223 000000DC 87EB                        xchg bx,bp
   224 000000DE 8BAF[2200]                  mov bp,[bx+fx_table]
   225 000000E2 81E5FF00                    and bp,0xff             ; effect function needs to fit in one byte to save 8 bytes
   226 000000E6 5B                          pop bx
   227 000000E7 FFD5                        call bp                 ; call the effect function
   228 000000E9 5D                          pop bp
   229                                  
   230                                  draw_char_color:
   231 000000EA 3C00                        cmp al,0
   232 000000EC 9C                          pushf
   233 000000ED 7D02                        jge .red
   234 000000EF F6D8                        neg al
   235                                    .red:
   236 000000F1 B900F0                      mov cx,RED << 8              ; ch=0xf0, cl=0
   237 000000F4 E83900                      call draw_char
   238 000000F7 9D                          popf
   239 000000F8 7D02                        jge .green_blue
   240 000000FA 30C0                        xor al,al               ; if negative then just red so clear (al=0) green and blue
   241                                    .green_blue:
   242 000000FC B508                        mov ch,GREEN
   243 000000FE E82F00                      call draw_char
   244 00000101 B5F4                        mov ch,BLUE
   245 00000103 E82A00                      call draw_char
   246                                    .next:  
   247 00000106 FEC2                        inc i                   ; i++
   248 00000108 83C708                      add di,8         
   249 0000010B 80FF0F                      cmp x,15
   250 0000010E 7CB8                        jl dot                  ; next col
   251 00000110 81C72001                    add di,4*COLS       
   252 00000114 81C7A000                    add di,160
   253 00000118 80FB0F                      cmp y,15
   254 0000011B 7CAB                        jl dot                  ; next line
   255 0000011D FEC6                        inc t
   256 0000011F 80FE1E                      cmp t,effect_timeout
   257 00000122 72A1                        jb draw                 ; next frame
   258 00000124 45                          inc bp                  ; inc effect
   259 00000125 30F6                        xor t,t                 ; reset time
   260 00000127 83FD06                      cmp bp,6
   261 0000012A 7C99                        jl draw                 ; next effect
   262 0000012C 31ED                        xor bp,bp               ; reset effect
   263 0000012E EB95                        jmp draw
   264                                  
   265                                  draw_char:                  ; es:di=vram (not increasing), al=char 0..15, destroys cx
   266 00000130 50                          push ax
   267 00000131 57                          push di
   268                                  
   269 00000132 51                          push cx
   270 00000133 07                          pop es                  ; es=bp (color channel now cx)
   271 00000134 0E                          push cs
   272 00000135 1F                          pop ds                  ; ds=cs
   273                                  
   274 00000136 B90400                      mov cx,4
   275 00000139 51                          push cx
   276 0000013A 51                          push cx
   277                                  
   278 0000013B 240F                        and al,15               ; limit al to 15
   279 0000013D 98                          cbw                     ; ah=0
   280                                     
   281 0000013E D2E0                        shl al,cl               ; al*=16
   282 00000140 05[ED01]                    add ax,bitmap_data
   283 00000143 96                          xchg si,ax              ; si = source address of rendered bitmap char
   284                                  
   285 00000144 59                          pop cx                  ;cx=4
   286 00000145 F3A5                        rep movsw
   287 00000147 81C71801                    add di,4*COLS-8
   288 0000014B 59                          pop cx                  ;cx=4
   289 0000014C F3A5                        rep movsw
   290                                  
   291 0000014E 5F                          pop di                    
   292 0000014F 58                          pop ax
   293 00000150 C3                          ret
   294                                  
   295                                  generate_chars:
   296 00000151 BF[ED01]                    mov di,bitmap_data      ; dest address of render data
   297 00000154 30FF                        xor bh,bh
   298                                    .render_char:
   299 00000156 30E4                        xor ah,ah
   300 00000158 88F8                        mov al,bh
   301 0000015A B90400                      mov cx,4                ; cl is also used below
   302 0000015D F6E1                        mul cl
   303 0000015F 89C6                        mov si,ax
   304 00000161 81C6[AD01]                  add si,img
   305                                    .render_char_part:        ; input requirement at first time cl=4
   306 00000165 AC                          lodsb                   ; use lodsb instead of movsb to keep a copy in al
   307 00000166 AA                          stosb                   ; draw in left top nibble
   308 00000167 53                          push bx                 ; save cur x and y
   309 00000168 51                          push cx                 ; cur loop counter (4,3,2,1)
   310 00000169 51                          push cx
   311 0000016A 5B                          pop bx                  ; bx = counter
   312 0000016B D1E3                        shl bx,1                ; bx *= 2
   313 0000016D 53                          push bx                 ; save counter*2 for right bottom
   314 0000016E 83FB02                      cmp bx,2                ; skip top line of left bottom nibble
   315 00000171 7403                        je .flip_bits
   316 00000173 884101                      mov [di+bx+1],al        ; draw in left bottom starting at line 3 instead of 4
   317                                  
   318                                    .flip_bits:                 ; flips all bits dropping highest bit
   319 00000176 B108                        mov cl,8                ; 8 bits to flip
   320 00000178 30E4                        xor ah,ah
   321                                    .flip_bit:
   322 0000017A BB0180                      mov bx,0x8001           ; bl=1, bh=128  bl doubles, bh halves
   323 0000017D D2E3                        shl bl,cl
   324 0000017F 84D8                        test al,bl
   325 00000181 7406                        jz .next_bit
   326 00000183 49                          dec cx
   327 00000184 D2EF                        shr bh,cl
   328 00000186 08FC                        or ah,bh
   329 00000188 41                          inc cx
   330                                    .next_bit:
   331 00000189 E2EF                        loop .flip_bit          ; loop 8 bits for flipping
   332 0000018B 886503                      mov [di+3],ah           ; draw in right top nibble
   333 0000018E 5B                          pop bx                  ; bx = counter*2
   334 0000018F 83FB02                      cmp bx,2                ; skip top line of right bottom nibble
   335 00000192 7403                        je .flip_done
   336 00000194 886105                      mov [di+bx+5],ah        ; draw in right bottom starting at line 3 instead of 4
   337                                    .flip_done:
   338 00000197 59                          pop cx                  ; restore loop counter
   339 00000198 5B                          pop bx                  ; restore x and y
   340 00000199 E2CA                        loop .render_char_part
   341                                    .clear_bottom_line:
   342 0000019B 83C707                      add di,7
   343 0000019E 30C0                        xor al,al
   344 000001A0 AA                          stosb                   ; right bottom
   345 000001A1 83C703                      add di,3
   346 000001A4 AA                          stosb                   ; left bottom
   347                                    .next_char:
   348 000001A5 FEC7                        inc bh                  ; next char
   349 000001A7 80FF10                      cmp bh,16
   350 000001AA 7CAA                        jl .render_char
   351 000001AC C3                          ret
   352                                  
   353                                  img:
   354 000001AD 00000000                    db 0,0,0,0
   355 000001B1 00000001                    db 0,0,0,1
   356 000001B5 00000003                    db 0,0,0,3
   357 000001B9 00000103                    db 0,0,1,3
   358 000001BD 00000307                    db 0,0,3,7
   359 000001C1 0000070F                    db 0,0,7,15
   360 000001C5 00030F1F                    db 0,3,15,31
   361 000001C9 00071F3F                    db 0,7,31,63
   362 000001CD 010F3F3F                    db 1,15,63,63
   363 000001D1 031F3F3F                    db 3,31,63,63
   364 000001D5 071F3F7F                    db 7,31,63,127
   365 000001D9 071F7F7F                    db 7,31,127,127
   366 000001DD 073F7F7F                    db 7,63,127,127
   367 000001E1 0F3F7F7F                    db 15,63,127,127
   368 000001E5 0F3F7FFF                    db 15,63,127,255
   369 000001E9 1F7FFFFF                    db 31,127,255,255
   370                                  
   371                                  %assign num $-$$
   372                                  %warning total num
   372          ******************       warning: total 493 [-w+user]
   373                                  
   374                                  bitmap_data:                          ; destination for 128 bytes rendered bitmap data
   375                                  
   376 000001ED 00<rep 59E13h>          times 368640-num db  0                 ; fill up with zeros until file size=360k
